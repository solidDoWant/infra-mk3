# Pull in a separate file that for some of the more important variables that are used elsewhere. This allow
# for defining them in the HelmRelease, making it the source of truth for the router config.
include /etc/keepalived/keepalived-vars.conf

global_defs {
    # Log VRRP advertisements for virtual router IDs not configured.
    log_unknown_vrids

    # This is needed to allow keepalived to run the VRRP notify scripts.
    enable_script_security
    script_user root root

    # Error if the include file is missing or cannot be read.
    include_check
}

vrrp_instance router {
    # Start all instance in BACKUP mode. They'll elect a master among themselves.
    state BACKUP
    # Use this interface for VRRP advertisements. If a pod is compromised, they won't be able to
    # affect the VRRP state of the routers, because the routers communicate over their own network.
    interface ${ROUTER_NETWORK_INTERFACE}
    # This value is arbitrary, but must be the same for all pods.
    virtual_router_id 51

    virtual_ipaddress {
        # This is the router's primary virtual IP address, and the link to attach it to.
        # This is used for routing client pod egress traffic specifically.
        # MACVLAN is used to avoid issues with arising from stale ARP entries in clients and
        # switches/bridges with learning enabled.
        # noprefixroute is needed to prevent the kernel from adding the link-scoped route automatically.
        # Without this, the route will get appended instead of prepended, and will never be matched.
        # See below for the workaround.
        ${EGRESS_VIP_ADDRESS}/${SUBNET_CIDR_BITS} dev ${VIP_UNDERLYING_INTERFACE} use_vmac noprefixroute

        # These are additional addresses, one for each gateway, that gateways should send ingress traffic to.
        # One per gateway is used so that the router can tell which gateway the traffic came from, and route return
        # traffic back to the correct gateway. Without this, the router tie the connection state back to the gateway
        # that originated the traffic, which would result in the traffic being sent to a random gateway.
        ~SEQ(OCTET, ${INGRESS_VIP_OCTET_START}, ${INGRESS_VIP_OCTET_END}) \
        ${INGRESS_VIP_PREFIX}.${OCTET}/${SUBNET_CIDR_BITS} dev ${VIP_UNDERLYING_INTERFACE} use_vmac noprefixroute
    }

    # Add/del a route to the local subnet with the VIP as the source. This will cause packets to use the VIP
    # as the source address when routing to the local subnet. This is needed to make sure that ICMP messages
    # (e.g. "fragmentation needed" or "time exceeded") are sent from the VIP address.

    # For some weird reason keepalived tries to process virtual_routes prior to brining the MACVLAN interface up,
    # which causes the route entries to fail. This causes keepalived to move to "FAULT" state.
    # To work around this, add the routes manually using the notify scripts.
    # TODO this current config will probably produce a separate MACVLAN interface for each VIP address - fix this if it does
    # ~LIST(EVENT, master,backup,fault,stop) \
    # notify_${EVENT} "/usr/local/bin/notify.sh ${EVENT} vrrp.51 ${EGRESS_VIP_ADDRESS} ${SUBNET_CIDR_BITS} ${GATEWAY_IP_PREFIX} ${GATEWAY_IP_OCTET_START} ${GATEWAY_IP_OCTET_END}"
    ~LIST(EVENT, master,backup,fault,stop) \
    notify_${EVENT} /sbin/ip route "${EVENT}" "${EGRESS_VIP_ADDRESS}/${SUBNET_CIDR_BITS}" dev vrrp.51 scope link src "${EGRESS_VIP_ADDRESS}"
}

# Defines a virtual server group for a specific port. This is configured for all ingress VIP addresses.
# Expected inputs:
# * $VS_PORT - The port the virtual server listens on.
# * $VS_OCTET_START - The start of the range of VIP octets to use.
# * $VS_OCTET_END - The end of the range of VIP octets to use.
$VS_GROUP= \
virtual_server_group virtual_servers_for_${VS_PORT} { \
    ~SEQ(VS_OCTET, ${VS_OCTET_START}, ${VS_OCTET_END}) ${INGRESS_VIP_PREFIX}.${VS_OCTET} ${VS_PORT}    \
}

# Defines a virtual server for a specific protocol, tied to a specific virtual server group.
# Expected inputs:
# * $VS_PORT - The port the virtual server listens on.
# * $PROTOCOL - The protocol the virtual server listens on. Either TCP or UDP.
# * $RS_OCTET_START - The start of the range of real server octets for the real servers for the traffic of the specified port.
# * $RS_OCTET_END - The end of the range of real server octets for the real servers for the traffic of the specified port.
$VS= \
virtual_server virtual_servers_for_${VS_PORT} { \
    lb_algo lc  \
    lb_kind NAT \
    protocol ${PROTOCOL}  \

    ~SEQ(RS_OCTET, ${RS_OCTET_START}, ${RS_OCTET_END}) \
    real_server 192.168.27.${RS_OCTET} ${VS_PORT} {  \
        PING_CHECK {} \
    }   \
}

# Full configuration that adds a virtual server group for each port, and
# a virtual server for each supported protocol (TCP, UDP).
# Expected inputs:
# * $VS_PORT - The port the virtual server listens on.
# * $VS_OCTET_START - The start of the range of VIP octets to use.
# * $VS_OCTET_END - The end of the range of VIP octets to use.
# * $RS_OCTET_START - The start of the range of real server octets for the real servers for the traffic of the specified port.
# * $RS_OCTET_END - The end of the range of real server octets for the real servers for the traffic of the specified port.
$FULL_VIRTUAL_SERVER_CONFIG= \
${VS_GROUP}   \
~LST(PROTOCOL, TCP, UDP) ${VS}

# Build the virtual server, virtual server group, and real server definitions for all
# ingress ports.
~LST( \
    {VS_PORT, RS_OCTET_START, RS_OCTET_END},  \
    {${INGRESS_PORT_1},0,15}, \
    {${INGRESS_PORT_2},16,31}, \
    {${INGRESS_PORT_3},32,47}, \
    {${INGRESS_PORT_4},48,63}, \
    {${INGRESS_PORT_5},64,79} \
) ${FULL_VIRTUAL_SERVER_CONFIG}
