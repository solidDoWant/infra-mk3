---
# Proxy postgres connections, changing auth to mTLS, using Envoy's Postgres proxy filter
# Uses file-based SDS for automatic certificate reloading
admin:
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8000

node:
  # Values are basically meaningless but must be set
  id: envoy-insurgency-postgres-proxy
  cluster: tug2

static_resources:
  clusters:
    - name: postgres_cluster
      connect_timeout: 1s
      type: STRICT_DNS
      load_assignment:
        cluster_name: postgres_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: insurgency-postgres-17-rw.tug2.svc.cluster.local
                      port_value: 5432
      health_checks:
        - timeout: 1s
          interval: 3s
          unhealthy_threshold: 2
          healthy_threshold: 1
          tcp_health_check: {}
      dns_lookup_family: V4_ONLY
      transport_socket:
        name: postgres_upstream_tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.starttls.v3.UpstreamStartTlsConfig
          tls_socket_config:
            common_tls_context:
              tls_params:
                tls_minimum_protocol_version: TLSv1_3
                tls_maximum_protocol_version: TLSv1_3
              # Unfortunately this doesn't currently work due to https://github.com/envoyproxy/envoy/issues/41850.
              # Leaving this here for when/if it is addressed.
              tls_certificate_sds_secret_configs:
                - name: postgres_client_cert
                  sds_config:
                    resource_api_version: V3
                    path_config_source:
                      path: /etc/envoy/postgres-client-cert-sds.yaml
                      watched_directory:
                        path: /mnt/postgres
              validation_context_sds_secret_config:
                name: postgres_serving_cert
                sds_config:
                  resource_api_version: V3
                  path_config_source:
                    path: /etc/envoy/postgres-validation-context-sds.yaml
                    watched_directory:
                      path: /mnt/root-ca
            auto_host_sni: true
            auto_sni_san_validation: true
      close_connections_on_host_health_failure: true
      ignore_health_on_host_removal: true

    - name: discord_cluster
      connect_timeout: 5s
      type: LOGICAL_DNS
      dns_lookup_family: V4_ONLY
      load_assignment:
        cluster_name: discord_cluster
        endpoints:
          - lb_endpoints:
              - endpoint:
                  address:
                    socket_address:
                      address: discord.com
                      port_value: 443
      transport_socket:
        name: envoy.transport_sockets.tls
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
          sni: discord.com
          common_tls_context:
            tls_params:
              tls_minimum_protocol_version: TLSv1_2
              tls_maximum_protocol_version: TLSv1_3

  listeners:
    - name: postgres_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 5432
      filter_chains:
        - filters:
            - name: envoy.filters.network.postgres_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.postgres_proxy.v3alpha.PostgresProxy
                stat_prefix: egress_postgres
                enable_sql_parsing: false
                upstream_ssl: REQUIRE
            - name: envoy.tcp_proxy
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.tcp_proxy.v3.TcpProxy
                stat_prefix: tcp_postgres
                cluster: postgres_cluster
                # Disable the idle timeout. This relies on the application to close idle connections. Some applications
                # (such as Harbor) don't handle Envoy-terminated connections well.
                idle_timeout: 0s

    - name: discord_webhook_listener
      address:
        socket_address:
          address: 0.0.0.0
          port_value: 80
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: discord_webhook
                codec_type: AUTO
                route_config:
                  name: discord_route
                  virtual_hosts:
                    - name: discord_service
                      domains: ["*"]
                      routes:
                        - match:
                            prefix: /
                          route:
                            cluster: discord_cluster
                            auto_host_rewrite: true
                http_filters:
                  - name: envoy.filters.http.lua
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                      default_source_code:
                        inline_string: |
                          -- Read the Discord webhook URL from a secret file
                          -- Re-reads the file every 60 seconds
                          -- Supports both full URLs and path-only values
                          local webhook_path_cache = nil
                          local cache_expiry = 0
                          local cache_ttl_seconds = 60

                          function extract_path(url)
                            -- Remove trailing whitespace
                            url = url:gsub("%s+$", "")
                            -- Check if it's a full URL (starts with http:// or https://)
                            local path = url:match("^https?://[^/]+(/.*)$")
                            if path then
                              return path
                            end
                            -- Otherwise assume it's already just the path
                            return url
                          end

                          function read_webhook_path()
                            local now = os.time()
                            if webhook_path_cache and now < cache_expiry then
                              return webhook_path_cache
                            end
                            local file = io.open("/mnt/discord-webhook/webhookUrl", "r")
                            if file then
                              local content = file:read("*all")
                              file:close()
                              webhook_path_cache = extract_path(content)
                              cache_expiry = now + cache_ttl_seconds
                            end
                            return webhook_path_cache
                          end

                          function envoy_on_request(request_handle)
                            local path = request_handle:headers():get(":path")
                            if path == "/discord-webhook" then
                              local webhook_path = read_webhook_path()
                              if webhook_path then
                                request_handle:headers():replace(":path", webhook_path)
                              else
                                request_handle:respond({[":status"] = "500"}, "Webhook path not configured")
                              end
                            else
                              request_handle:respond({[":status"] = "404"}, "Not found")
                            end
                          end
                  - name: envoy.filters.http.router
                    typed_config:
                      "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
